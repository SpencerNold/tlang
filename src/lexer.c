/* Generated by re2c 4.2 on Fri May  2 08:51:00 2025 */
#line 1 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
#include <stdlib.h>
#include <string.h>

#include "lexer.h"

#line 9 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
#define YYMAXFILL 5
#line 6 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"

#define SIZE 64 * 1024

struct lex_token_stream_t {
    tok_queue_t* queue;
    int value;
};

struct lex_input_t {
    FILE* file;
    unsigned char buf[SIZE + YYMAXFILL];
    unsigned char* limit;
    unsigned char* current;
    unsigned char* marker;
    unsigned char* token;
    int eof;
};

lex_input_t* lex_open(FILE* file) {
    lex_input_t* input = (lex_input_t*) malloc(sizeof(lex_input_t));
    if (input == NULL) {
        return NULL;
    }
    input->file = file;
    input->limit = input->buf + SIZE;
    input->current = input->limit;
    input->marker = input->limit;
    input->token = input->limit;
    input->eof = 0;
    return input;
}

void lex_close_input(lex_input_t* input) {
    free(input);
}

int fill(lex_input_t* input, size_t size) {
    if (input->eof) {
        return 0;
    }
    const size_t free = input->token - input->buf;
    if (free < size) {
        return 0;
    }
    memmove(input->buf, input->token, input->limit - input->token);
    input->limit -= free;
    input->current -= free;
    input->marker -= free;
    input->token -= free;
    input->limit += fread(input->limit, 1, free, input->file);
    if (input->limit < input->buf + SIZE) {
        input->eof = 1;
        memset(input->limit, 0, YYMAXFILL);
        input->limit += YYMAXFILL;
    }
    return 1;
}

void _append_bool_literal(lex_token_stream_t* stream, int type) {
    append_int_tok_queue(stream->queue, type, type == TRUE_VALUE);
}

lex_token_stream_t* lex_run(lex_input_t* input) {
    lex_token_stream_t* stream = (lex_token_stream_t*) malloc(sizeof(lex_token_stream_t));
    stream->queue = allocate_tok_queue();
    stream->value = 0;
    for (;;) {
        input->token = input->current;
        
#line 81 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
{
	char yych;
	unsigned int yyaccept = 0;
	if ((input->limit - input->current) < 5) if (!fill(input, 5)) return 0;
	yych = *input->current;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case '\n':
		case '\v':
		case '\r':
		case ' ': goto yy4;
		case '/': goto yy6;
		case 'f': goto yy7;
		case 't': goto yy8;
		default: goto yy2;
	}
yy1:
	++input->current;
#line 84 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
	{
                stream->value = input->limit - input->token == YYMAXFILL;
                break;
            }
#line 106 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
yy2:
	++input->current;
yy3:
#line 105 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
	{ 
                lex_close_token_stream(stream);
                return NULL;
            }
#line 115 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
yy4:
	yyaccept = 0;
	input->marker = ++input->current;
	if (input->limit <= input->current) if (!fill(input, 1)) return 0;
	yych = *input->current;
	switch (yych) {
		case '\t':
		case '\n':
		case '\v':
		case '\r':
		case ' ': goto yy4;
		case '/': goto yy9;
		default: goto yy5;
	}
yy5:
#line 91 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
	{ continue; }
#line 133 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
yy6:
	yych = *++input->current;
	switch (yych) {
		case '/': goto yy11;
		default: goto yy3;
	}
yy7:
	yyaccept = 1;
	yych = *(input->marker = ++input->current);
	switch (yych) {
		case 'a': goto yy12;
		default: goto yy3;
	}
yy8:
	yyaccept = 1;
	yych = *(input->marker = ++input->current);
	switch (yych) {
		case 'r': goto yy13;
		default: goto yy3;
	}
yy9:
	++input->current;
	if (input->limit <= input->current) if (!fill(input, 1)) return 0;
	yych = *input->current;
	switch (yych) {
		case '/': goto yy11;
		default: goto yy10;
	}
yy10:
	input->current = input->marker;
	if (yyaccept == 0) goto yy5;
	else goto yy3;
yy11:
	++input->current;
	if (input->limit <= input->current) if (!fill(input, 1)) return 0;
	yych = *input->current;
	switch (yych) {
		case '\n': goto yy4;
		default: goto yy11;
	}
yy12:
	yych = *++input->current;
	switch (yych) {
		case 'l': goto yy14;
		default: goto yy10;
	}
yy13:
	yych = *++input->current;
	switch (yych) {
		case 'u': goto yy15;
		default: goto yy10;
	}
yy14:
	yych = *++input->current;
	switch (yych) {
		case 's': goto yy16;
		default: goto yy10;
	}
yy15:
	yych = *++input->current;
	switch (yych) {
		case 'e': goto yy17;
		default: goto yy10;
	}
yy16:
	yych = *++input->current;
	switch (yych) {
		case 'e': goto yy18;
		default: goto yy10;
	}
yy17:
	++input->current;
#line 98 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
	{
                _append_bool_literal(stream, TRUE_VALUE);
            }
#line 210 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
yy18:
	++input->current;
#line 101 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"
	{
                _append_bool_literal(stream, FALSE_VALUE);
            }
#line 217 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.c"
}
#line 109 "/Users/spencernold/Documents/Workspaces/GitHub/tlang/src/lexer.re"

    }
    return stream;
}

token_t* lex_stream_next(lex_token_stream_t* stream) {
    return poll_tok_queue(stream->queue);
}

int lex_token_type(token_t* token) {
    
}

void lex_free_token(token_t* token) {
    free_token(token);
}

void lex_close_token_stream(lex_token_stream_t* stream) {
    free_tok_queue(stream->queue);
    free(stream);
}